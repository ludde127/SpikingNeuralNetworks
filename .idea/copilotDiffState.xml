<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/testing.rs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/testing.rs" />
              <option name="originalContent" value="use crate::constants::{STEPS_PER_IMAGE, STEP_SIZE_MS};&#10;use crate::network::Network;&#10;use indicatif::{ProgressBar, ProgressStyle};&#10;use rayon::prelude::ParallelIterator;&#10;use rayon::prelude::*;&#10;&#10;pub fn test_network(&#10;    network: &amp;Network,&#10;    test_set: &amp;[(Vec&lt;f64&gt;, usize)],&#10;    output_neuron_indices: &amp;[usize],&#10;) {&#10;    println!(&quot;\n--- Testing Phase ---&quot;);&#10;&#10;    // Pre-convert all test images to input vectors&#10;    println!(&quot;Pre-processing test images...&quot;);&#10;    let test_inputs: Vec&lt;(Vec&lt;Vec&lt;f64&gt;&gt;, usize)&gt; = test_set&#10;        .par_iter()&#10;        .map(|(img_data, label)| {&#10;            let input_vector: Vec&lt;Vec&lt;f64&gt;&gt; = (0..STEPS_PER_IMAGE)&#10;                .map(|_| {&#10;                    img_data&#10;                        .iter()&#10;                        .map(|&amp;pixel_val| pixel_val * 0.20)&#10;                        .collect()&#10;                })&#10;                .collect();&#10;            (input_vector, *label)&#10;        })&#10;        .collect();&#10;&#10;    let mut correct_predictions = 0;&#10;    let mut confusion_matrix = vec![vec![0; 2]; 2];&#10;&#10;    let test_pb = ProgressBar::new(test_inputs.len() as u64);&#10;    test_pb.set_style(&#10;        ProgressStyle::default_bar()&#10;            .template(&quot;[{elapsed_precise}] {bar:40.green/blue} {pos}/{len} {msg}&quot;)&#10;            .unwrap()&#10;            .progress_chars(&quot;##-&quot;),&#10;    );&#10;&#10;    for (input_vector, actual_label) in test_inputs.iter() {&#10;        let predicted_label =&#10;            network.predict(input_vector, STEPS_PER_IMAGE, STEP_SIZE_MS, output_neuron_indices);&#10;&#10;        confusion_matrix[*actual_label][predicted_label] += 1;&#10;&#10;        if predicted_label == *actual_label {&#10;            correct_predictions += 1;&#10;        }&#10;&#10;        test_pb.inc(1);&#10;    }&#10;    test_pb.finish_with_message(&quot;Testing complete&quot;);&#10;&#10;    let accuracy = (correct_predictions as f64 / test_inputs.len() as f64) * 100.0;&#10;&#10;    println!(&quot;\n--- Results ---&quot;);&#10;    println!(&#10;        &quot;Test Accuracy: {:.2}% ({}/{})&quot;,&#10;        accuracy,&#10;        correct_predictions,&#10;        test_inputs.len()&#10;    );&#10;&#10;    // Display confusion matrix&#10;    println!(&quot;\n--- Confusion Matrix ---&quot;);&#10;    println!(&quot;                  Predicted&quot;);&#10;    println!(&quot;                  Setosa  Versicolour&quot;);&#10;    println!(&#10;        &quot;Actual Setosa       {:&gt;3}      {:&gt;3}&quot;,&#10;        confusion_matrix[0][0], confusion_matrix[0][1]&#10;    );&#10;    println!(&#10;        &quot;       Versicolour  {:&gt;3}      {:&gt;3}&quot;,&#10;        confusion_matrix[1][0], confusion_matrix[1][1]&#10;    );&#10;}&#10;" />
              <option name="updatedContent" value="use crate::constants::{STEPS_PER_IMAGE, STEP_SIZE_MS};&#10;use crate::network::Network;&#10;use indicatif::{ProgressBar, ProgressStyle};&#10;use rayon::prelude::*;&#10;&#10;pub fn test_network(&#10;    network: &amp;Network,&#10;    test_set: &amp;[(Vec&lt;f64&gt;, usize)],&#10;    output_neuron_indices: &amp;[usize],&#10;) {&#10;    println!(&quot;\n--- Testing Phase ---&quot;);&#10;&#10;    // Pre-convert all test images to input vectors&#10;    println!(&quot;Pre-processing test images...&quot;);&#10;    let test_inputs: Vec&lt;(Vec&lt;Vec&lt;f64&gt;&gt;, usize)&gt; = test_set&#10;        .par_iter()&#10;        .map(|(img_data, label)| {&#10;            let input_vector: Vec&lt;Vec&lt;f64&gt;&gt; = (0..STEPS_PER_IMAGE)&#10;                .map(|_| {&#10;                    img_data&#10;                        .iter()&#10;                        .map(|&amp;pixel_val| pixel_val * 0.20)&#10;                        .collect()&#10;                })&#10;                .collect();&#10;            (input_vector, *label)&#10;        })&#10;        .collect();&#10;&#10;    let mut correct_predictions = 0;&#10;    let mut confusion_matrix = vec![vec![0; 2]; 2];&#10;    let mut printed_setosa = 0;&#10;    let mut printed_versicolour = 0;&#10;    const MAX_PRINTS_PER_CLASS: usize = 2;&#10;&#10;    let test_pb = ProgressBar::new(test_inputs.len() as u64);&#10;    test_pb.set_style(&#10;        ProgressStyle::default_bar()&#10;            .template(&quot;[{elapsed_precise}] {bar:40.green/blue} {pos}/{len} {msg}&quot;)&#10;            .unwrap()&#10;            .progress_chars(&quot;##-&quot;),&#10;    );&#10;&#10;    for (i, (input_vector, actual_label)) in test_inputs.iter().enumerate() {&#10;        let (predicted_label, membrane_potentials) =&#10;            network.predict(input_vector, STEPS_PER_IMAGE, STEP_SIZE_MS, output_neuron_indices);&#10;&#10;        confusion_matrix[*actual_label][predicted_label] += 1;&#10;&#10;        if predicted_label == *actual_label {&#10;            correct_predictions += 1;&#10;        }&#10;&#10;        // Print membrane potentials for a few samples&#10;        let class_name = if *actual_label == 0 { &quot;Setosa&quot; } else { &quot;Versicolour&quot; };&#10;        if *actual_label == 0 &amp;&amp; printed_setosa &lt; MAX_PRINTS_PER_CLASS {&#10;            let plot_filename = format!(&quot;membrane_potential_setosa_{}.png&quot;, i);&#10;            println!(&quot;\n--- Sample: {} (Actual) ---&quot;, class_name);&#10;            println!(&quot;Predicted: {}&quot;, if predicted_label == 0 { &quot;Setosa&quot; } else { &quot;Versicolour&quot; });&#10;            network.plot_membrane_potentials(&amp;membrane_potentials, &amp;plot_filename, output_neuron_indices).unwrap();&#10;            println!(&quot;Membrane potential plot saved to {}&quot;, plot_filename);&#10;            printed_setosa += 1;&#10;        } else if *actual_label == 1 &amp;&amp; printed_versicolour &lt; MAX_PRINTS_PER_CLASS {&#10;            let plot_filename = format!(&quot;membrane_potential_versicolour_{}.png&quot;, i);&#10;            println!(&quot;\n--- Sample: {} (Actual) ---&quot;, class_name);&#10;            println!(&quot;Predicted: {}&quot;, if predicted_label == 1 { &quot;Versicolour&quot; } else { &quot;Setosa&quot; });&#10;            network.plot_membrane_potentials(&amp;membrane_potentials, &amp;plot_filename, output_neuron_indices).unwrap();&#10;            println!(&quot;Membrane potential plot saved to {}&quot;, plot_filename);&#10;            printed_versicolour += 1;&#10;        }&#10;&#10;        test_pb.inc(1);&#10;    }&#10;    test_pb.finish_with_message(&quot;Testing complete&quot;);&#10;&#10;    let accuracy = (correct_predictions as f64 / test_inputs.len() as f64) * 100.0;&#10;&#10;    println!(&quot;\n--- Results ---&quot;);&#10;    println!(&#10;        &quot;Test Accuracy: {:.2}% ({}/{})&quot;,&#10;        accuracy,&#10;        correct_predictions,&#10;        test_inputs.len()&#10;    );&#10;&#10;    // Display confusion matrix&#10;    println!(&quot;\n--- Confusion Matrix ---&quot;);&#10;    println!(&quot;                  Predicted&quot;);&#10;    println!(&quot;                  Setosa  Versicolour&quot;);&#10;    println!(&#10;        &quot;Actual Setosa       {:&gt;3}      {:&gt;3}&quot;,&#10;        confusion_matrix[0][0], confusion_matrix[0][1]&#10;    );&#10;    println!(&#10;        &quot;       Versicolour  {:&gt;3}      {:&gt;3}&quot;,&#10;        confusion_matrix[1][0], confusion_matrix[1][1]&#10;    );&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>