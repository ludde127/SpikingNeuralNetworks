<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/simulation.rs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/simulation.rs" />
              <option name="originalContent" value="use crate::neuron::{Neuron, NeuronBehavior};&#10;use crate::reward_system::RewardSystem;&#10;use crate::spike_event::SpikeEvent;&#10;use crate::synapse::{Synapse};&#10;use rand::Rng;&#10;use std::collections::VecDeque;&#10;use std::sync::{Arc, RwLock};&#10;&#10;pub struct Simulation {&#10;    spike_queue: VecDeque&lt;Arc&lt;RwLock&lt;SpikeEvent&gt;&gt;&gt;,&#10;    dt: f32,&#10;    pub time: f32,&#10;    neurons: Vec&lt;Arc&lt;RwLock&lt;Neuron&gt;&gt;&gt;,&#10;    reward_system: RewardSystem,&#10;    current_trial_spike_events: Vec&lt;Arc&lt;RwLock&lt;SpikeEvent&gt;&gt;&gt;,&#10;}&#10;&#10;impl Simulation {&#10;    pub fn new(dt: f32, input_neurons: Vec&lt;Arc&lt;RwLock&lt;Neuron&gt;&gt;&gt;) -&gt; Self {&#10;        Simulation {&#10;            spike_queue: VecDeque::new(),&#10;            dt,&#10;            time: 0.0,&#10;            neurons: input_neurons,&#10;            reward_system: RewardSystem::new(),&#10;            current_trial_spike_events: Vec::new(),&#10;        }&#10;    }&#10;&#10;    pub fn reward(&amp;mut self, reward: f32) {&#10;        self.reward_system.add_reward(self.time, reward);&#10;        if self.current_trial_spike_events.is_empty() {&#10;            return;&#10;        }&#10;        self.reward_system&#10;            .update_synapses(self.time, &amp;self.current_trial_spike_events);&#10;        self.current_trial_spike_events = Vec::new();&#10;    }&#10;&#10;    // New: expose the reward system's EMA average reward at current sim time&#10;    pub fn average_reward(&amp;self) -&gt; f32 {&#10;        self.reward_system.get_average_reward(self.time).unwrap_or(0.0)&#10;    }&#10;&#10;    // New: expose delta error history for plotting&#10;    pub fn delta_error_history(&amp;self) -&gt; &amp;[f32] {&#10;        self.reward_system.delta_error_history()&#10;    }&#10;&#10;    fn send_action_potential(&amp;mut self, neuron: Arc&lt;RwLock&lt;Neuron&gt;&gt;) {&#10;        let n = neuron.read().unwrap();&#10;        for syn in &amp;n.exiting_synapses {&#10;            let wsyn = syn.write().unwrap();&#10;            let spike_event = Arc::new(RwLock::new(SpikeEvent {&#10;                synapse: syn.clone(),&#10;                delivery_time: self.time + wsyn.delay,&#10;                presynaptic_ema_firing_rate_before_spike: neuron.read().unwrap().ema_firing_rate_before_last_spike&#10;            }));&#10;            self.spike_queue.push_back(spike_event);&#10;        }&#10;    }&#10;&#10;    fn step_process_nodes(&amp;mut self, neurons: Vec&lt;Arc&lt;RwLock&lt;Neuron&gt;&gt;&gt;) {&#10;        let mut firing_neurons = Vec::with_capacity(neurons.len() * 5);&#10;        for neuron in &amp;neurons {&#10;            let fired = {&#10;                let mut n = neuron.write().unwrap();&#10;                n.step(self.time)&#10;            };&#10;            if fired {&#10;                // Neuron fired, create spike events&#10;                firing_neurons.push(neuron.clone());&#10;            }&#10;        }&#10;        for neuron in firing_neurons {&#10;            self.send_action_potential(neuron.clone());&#10;        }&#10;    }&#10;&#10;    pub fn input_external_stimuli(&amp;mut self, node: Arc&lt;RwLock&lt;Neuron&gt;&gt;, magnitude: f32) {&#10;        node.write().unwrap().receive(magnitude, self.time);&#10;        self.step_process_nodes(vec![node]);&#10;    }&#10;&#10;    pub fn random_noise(&amp;mut self, min: f32, max: f32, percent: f32, rng: &amp;mut impl Rng) {&#10;        // Adds random noise to a percentage of neurons&#10;        let num_neurons = (self.neurons.len() as f32 * percent).ceil() as usize;&#10;        let mut selected_indices = Vec::with_capacity(num_neurons);&#10;        let mut modified_neurons = Vec::with_capacity(num_neurons);&#10;        while selected_indices.len() &lt; num_neurons {&#10;            let idx = rng.gen_range(0..self.neurons.len());&#10;            if !selected_indices.contains(&amp;idx) {&#10;                selected_indices.push(idx);&#10;                self.neurons[idx]&#10;                    .write()&#10;                    .unwrap()&#10;                    .receive(rng.gen_range(min..max), self.time);&#10;                modified_neurons.push(self.neurons[idx].clone());&#10;            }&#10;        }&#10;        self.step_process_nodes(modified_neurons);&#10;    }&#10;&#10;    pub(crate) fn step(&amp;mut self) {&#10;        // Process external stimuli&#10;        self.time += self.dt;&#10;        self.process_events();&#10;    }&#10;&#10;    fn process_events(&amp;mut self) {&#10;        // May be roughly correct size&#10;        let mut new_firing_neurons = Vec::with_capacity(self.spike_queue.len() * 5);&#10;        while let Some(event) = self.spike_queue.front() {&#10;            let delivery_time = event.read().unwrap().delivery_time as f32;&#10;            if delivery_time &lt;= self.time {&#10;                let event = self.spike_queue.pop_front().unwrap();&#10;                let synapse = event.read().unwrap().synapse.clone();&#10;                let wsyn = synapse.write().unwrap();&#10;                let post_neuron = wsyn.get_postsynaptic_neuron();&#10;                let mut n = post_neuron.write().unwrap();&#10;                n.receive(wsyn.get_weight(), self.time);&#10;&#10;                if n.will_fire(delivery_time) {&#10;                    // Neuron fired, create spike events&#10;                    new_firing_neurons.push(post_neuron.clone());&#10;                    self.current_trial_spike_events.push(event)&#10;                }&#10;            } else {&#10;                break;&#10;            }&#10;        }&#10;&#10;        // Could be more optimized if we check for duplicated nodes in the new_firing_neurons&#10;        self.step_process_nodes(new_firing_neurons);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="use crate::neuron::{Neuron, NeuronBehavior};&#10;use crate::reward_system::RewardSystem;&#10;use crate::spike_event::SpikeEvent;&#10;use crate::synapse::{Synapse};&#10;use rand::Rng;&#10;use std::collections::VecDeque;&#10;use std::sync::{Arc, RwLock};&#10;&#10;pub struct Simulation {&#10;    spike_queue: VecDeque&lt;Arc&lt;RwLock&lt;SpikeEvent&gt;&gt;&gt;,&#10;    dt: f32,&#10;    pub time: f32,&#10;    neurons: Vec&lt;Arc&lt;RwLock&lt;Neuron&gt;&gt;&gt;,&#10;    reward_system: RewardSystem,&#10;    current_trial_spike_events: Vec&lt;Arc&lt;RwLock&lt;SpikeEvent&gt;&gt;&gt;,&#10;}&#10;&#10;impl Simulation {&#10;    pub fn new(dt: f32, input_neurons: Vec&lt;Arc&lt;RwLock&lt;Neuron&gt;&gt;&gt;) -&gt; Self {&#10;        Simulation {&#10;            spike_queue: VecDeque::new(),&#10;            dt,&#10;            time: 0.0,&#10;            neurons: input_neurons,&#10;            reward_system: RewardSystem::new(),&#10;            current_trial_spike_events: Vec::new(),&#10;        }&#10;    }&#10;&#10;    pub fn reward(&amp;mut self, reward: f32) {&#10;        self.reward_system.add_reward(self.time, reward);&#10;        // Always call update_synapses to record delta error per learning step,&#10;        // even if there were no spike events (no weight updates will occur).&#10;        self.reward_system&#10;            .update_synapses(self.time, &amp;self.current_trial_spike_events);&#10;        self.current_trial_spike_events = Vec::new();&#10;    }&#10;&#10;    // New: expose the reward system's EMA average reward at current sim time&#10;    pub fn average_reward(&amp;self) -&gt; f32 {&#10;        self.reward_system.get_average_reward(self.time).unwrap_or(0.0)&#10;    }&#10;&#10;    // New: expose delta error history for plotting&#10;    pub fn delta_error_history(&amp;self) -&gt; &amp;[f32] {&#10;        self.reward_system.delta_error_history()&#10;    }&#10;&#10;    fn send_action_potential(&amp;mut self, neuron: Arc&lt;RwLock&lt;Neuron&gt;&gt;) {&#10;        let n = neuron.read().unwrap();&#10;        for syn in &amp;n.exiting_synapses {&#10;            let wsyn = syn.write().unwrap();&#10;            let spike_event = Arc::new(RwLock::new(SpikeEvent {&#10;                synapse: syn.clone(),&#10;                delivery_time: self.time + wsyn.delay,&#10;                presynaptic_ema_firing_rate_before_spike: neuron.read().unwrap().ema_firing_rate_before_last_spike&#10;            }));&#10;            self.spike_queue.push_back(spike_event);&#10;        }&#10;    }&#10;&#10;    fn step_process_nodes(&amp;mut self, neurons: Vec&lt;Arc&lt;RwLock&lt;Neuron&gt;&gt;&gt;) {&#10;        let mut firing_neurons = Vec::with_capacity(neurons.len() * 5);&#10;        for neuron in &amp;neurons {&#10;            let fired = {&#10;                let mut n = neuron.write().unwrap();&#10;                n.step(self.time)&#10;            };&#10;            if fired {&#10;                // Neuron fired, create spike events&#10;                firing_neurons.push(neuron.clone());&#10;            }&#10;        }&#10;        for neuron in firing_neurons {&#10;            self.send_action_potential(neuron.clone());&#10;        }&#10;    }&#10;&#10;    pub fn input_external_stimuli(&amp;mut self, node: Arc&lt;RwLock&lt;Neuron&gt;&gt;, magnitude: f32) {&#10;        node.write().unwrap().receive(magnitude, self.time);&#10;        self.step_process_nodes(vec![node]);&#10;    }&#10;&#10;    pub fn random_noise(&amp;mut self, min: f32, max: f32, percent: f32, rng: &amp;mut impl Rng) {&#10;        // Adds random noise to a percentage of neurons&#10;        let num_neurons = (self.neurons.len() as f32 * percent).ceil() as usize;&#10;        let mut selected_indices = Vec::with_capacity(num_neurons);&#10;        let mut modified_neurons = Vec::with_capacity(num_neurons);&#10;        while selected_indices.len() &lt; num_neurons {&#10;            let idx = rng.gen_range(0..self.neurons.len());&#10;            if !selected_indices.contains(&amp;idx) {&#10;                selected_indices.push(idx);&#10;                self.neurons[idx]&#10;                    .write()&#10;                    .unwrap()&#10;                    .receive(rng.gen_range(min..max), self.time);&#10;                modified_neurons.push(self.neurons[idx].clone());&#10;            }&#10;        }&#10;        self.step_process_nodes(modified_neurons);&#10;    }&#10;&#10;    pub(crate) fn step(&amp;mut self) {&#10;        // Process external stimuli&#10;        self.time += self.dt;&#10;        self.process_events();&#10;    }&#10;&#10;    fn process_events(&amp;mut self) {&#10;        // May be roughly correct size&#10;        let mut new_firing_neurons = Vec::with_capacity(self.spike_queue.len() * 5);&#10;        while let Some(event) = self.spike_queue.front() {&#10;            let delivery_time = event.read().unwrap().delivery_time as f32;&#10;            if delivery_time &lt;= self.time {&#10;                let event = self.spike_queue.pop_front().unwrap();&#10;                let synapse = event.read().unwrap().synapse.clone();&#10;                let wsyn = synapse.write().unwrap();&#10;                let post_neuron = wsyn.get_postsynaptic_neuron();&#10;                let mut n = post_neuron.write().unwrap();&#10;                n.receive(wsyn.get_weight(), self.time);&#10;&#10;                if n.will_fire(delivery_time) {&#10;                    // Neuron fired, create spike events&#10;                    new_firing_neurons.push(post_neuron.clone());&#10;                    self.current_trial_spike_events.push(event)&#10;                }&#10;            } else {&#10;                break;&#10;            }&#10;        }&#10;&#10;        // Could be more optimized if we check for duplicated nodes in the new_firing_neurons&#10;        self.step_process_nodes(new_firing_neurons);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/testing.rs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/testing.rs" />
              <option name="originalContent" value="use crate::constants::{STEPS_PER_IMAGE, STEP_SIZE_MS};&#10;use crate::network::Network;&#10;use indicatif::{ProgressBar, ProgressStyle};&#10;use rayon::prelude::ParallelIterator;&#10;use rayon::prelude::*;&#10;&#10;pub fn test_network(&#10;    network: &amp;Network,&#10;    test_set: &amp;[(Vec&lt;f64&gt;, usize)],&#10;    output_neuron_indices: &amp;[usize],&#10;) {&#10;    println!(&quot;\n--- Testing Phase ---&quot;);&#10;&#10;    // Pre-convert all test images to input vectors&#10;    println!(&quot;Pre-processing test images...&quot;);&#10;    let test_inputs: Vec&lt;(Vec&lt;Vec&lt;f64&gt;&gt;, usize)&gt; = test_set&#10;        .par_iter()&#10;        .map(|(img_data, label)| {&#10;            let input_vector: Vec&lt;Vec&lt;f64&gt;&gt; = (0..STEPS_PER_IMAGE)&#10;                .map(|_| {&#10;                    img_data&#10;                        .iter()&#10;                        .map(|&amp;pixel_val| pixel_val * 0.20)&#10;                        .collect()&#10;                })&#10;                .collect();&#10;            (input_vector, *label)&#10;        })&#10;        .collect();&#10;&#10;    let mut correct_predictions = 0;&#10;    let mut confusion_matrix = vec![vec![0; 2]; 2];&#10;&#10;    let test_pb = ProgressBar::new(test_inputs.len() as u64);&#10;    test_pb.set_style(&#10;        ProgressStyle::default_bar()&#10;            .template(&quot;[{elapsed_precise}] {bar:40.green/blue} {pos}/{len} {msg}&quot;)&#10;            .unwrap()&#10;            .progress_chars(&quot;##-&quot;),&#10;    );&#10;&#10;    for (input_vector, actual_label) in test_inputs.iter() {&#10;        let predicted_label =&#10;            network.predict(input_vector, STEPS_PER_IMAGE, STEP_SIZE_MS, output_neuron_indices);&#10;&#10;        confusion_matrix[*actual_label][predicted_label] += 1;&#10;&#10;        if predicted_label == *actual_label {&#10;            correct_predictions += 1;&#10;        }&#10;&#10;        test_pb.inc(1);&#10;    }&#10;    test_pb.finish_with_message(&quot;Testing complete&quot;);&#10;&#10;    let accuracy = (correct_predictions as f64 / test_inputs.len() as f64) * 100.0;&#10;&#10;    println!(&quot;\n--- Results ---&quot;);&#10;    println!(&#10;        &quot;Test Accuracy: {:.2}% ({}/{})&quot;,&#10;        accuracy,&#10;        correct_predictions,&#10;        test_inputs.len()&#10;    );&#10;&#10;    // Display confusion matrix&#10;    println!(&quot;\n--- Confusion Matrix ---&quot;);&#10;    println!(&quot;                  Predicted&quot;);&#10;    println!(&quot;                  Setosa  Versicolour&quot;);&#10;    println!(&#10;        &quot;Actual Setosa       {:&gt;3}      {:&gt;3}&quot;,&#10;        confusion_matrix[0][0], confusion_matrix[0][1]&#10;    );&#10;    println!(&#10;        &quot;       Versicolour  {:&gt;3}      {:&gt;3}&quot;,&#10;        confusion_matrix[1][0], confusion_matrix[1][1]&#10;    );&#10;}&#10;" />
              <option name="updatedContent" value="use crate::constants::{STEPS_PER_IMAGE, STEP_SIZE_MS};&#10;use crate::network::Network;&#10;use indicatif::{ProgressBar, ProgressStyle};&#10;use rayon::prelude::*;&#10;&#10;pub fn test_network(&#10;    network: &amp;Network,&#10;    test_set: &amp;[(Vec&lt;f64&gt;, usize)],&#10;    output_neuron_indices: &amp;[usize],&#10;) {&#10;    println!(&quot;\n--- Testing Phase ---&quot;);&#10;&#10;    // Pre-convert all test images to input vectors&#10;    println!(&quot;Pre-processing test images...&quot;);&#10;    let test_inputs: Vec&lt;(Vec&lt;Vec&lt;f64&gt;&gt;, usize)&gt; = test_set&#10;        .par_iter()&#10;        .map(|(img_data, label)| {&#10;            let input_vector: Vec&lt;Vec&lt;f64&gt;&gt; = (0..STEPS_PER_IMAGE)&#10;                .map(|_| {&#10;                    img_data&#10;                        .iter()&#10;                        .map(|&amp;pixel_val| pixel_val * 0.20)&#10;                        .collect()&#10;                })&#10;                .collect();&#10;            (input_vector, *label)&#10;        })&#10;        .collect();&#10;&#10;    let mut correct_predictions = 0;&#10;    let mut confusion_matrix = vec![vec![0; 2]; 2];&#10;    let mut printed_setosa = 0;&#10;    let mut printed_versicolour = 0;&#10;    const MAX_PRINTS_PER_CLASS: usize = 2;&#10;&#10;    let test_pb = ProgressBar::new(test_inputs.len() as u64);&#10;    test_pb.set_style(&#10;        ProgressStyle::default_bar()&#10;            .template(&quot;[{elapsed_precise}] {bar:40.green/blue} {pos}/{len} {msg}&quot;)&#10;            .unwrap()&#10;            .progress_chars(&quot;##-&quot;),&#10;    );&#10;&#10;    for (i, (input_vector, actual_label)) in test_inputs.iter().enumerate() {&#10;        let (predicted_label, membrane_potentials) =&#10;            network.predict(input_vector, STEPS_PER_IMAGE, STEP_SIZE_MS, output_neuron_indices);&#10;&#10;        confusion_matrix[*actual_label][predicted_label] += 1;&#10;&#10;        if predicted_label == *actual_label {&#10;            correct_predictions += 1;&#10;        }&#10;&#10;        // Print membrane potentials for a few samples&#10;        let class_name = if *actual_label == 0 { &quot;Setosa&quot; } else { &quot;Versicolour&quot; };&#10;        if *actual_label == 0 &amp;&amp; printed_setosa &lt; MAX_PRINTS_PER_CLASS {&#10;            let plot_filename = format!(&quot;membrane_potential_setosa_{}.png&quot;, i);&#10;            println!(&quot;\n--- Sample: {} (Actual) ---&quot;, class_name);&#10;            println!(&quot;Predicted: {}&quot;, if predicted_label == 0 { &quot;Setosa&quot; } else { &quot;Versicolour&quot; });&#10;            network.plot_membrane_potentials(&amp;membrane_potentials, &amp;plot_filename, output_neuron_indices).unwrap();&#10;            println!(&quot;Membrane potential plot saved to {}&quot;, plot_filename);&#10;            printed_setosa += 1;&#10;        } else if *actual_label == 1 &amp;&amp; printed_versicolour &lt; MAX_PRINTS_PER_CLASS {&#10;            let plot_filename = format!(&quot;membrane_potential_versicolour_{}.png&quot;, i);&#10;            println!(&quot;\n--- Sample: {} (Actual) ---&quot;, class_name);&#10;            println!(&quot;Predicted: {}&quot;, if predicted_label == 1 { &quot;Versicolour&quot; } else { &quot;Setosa&quot; });&#10;            network.plot_membrane_potentials(&amp;membrane_potentials, &amp;plot_filename, output_neuron_indices).unwrap();&#10;            println!(&quot;Membrane potential plot saved to {}&quot;, plot_filename);&#10;            printed_versicolour += 1;&#10;        }&#10;&#10;        test_pb.inc(1);&#10;    }&#10;    test_pb.finish_with_message(&quot;Testing complete&quot;);&#10;&#10;    let accuracy = (correct_predictions as f64 / test_inputs.len() as f64) * 100.0;&#10;&#10;    println!(&quot;\n--- Results ---&quot;);&#10;    println!(&#10;        &quot;Test Accuracy: {:.2}% ({}/{})&quot;,&#10;        accuracy,&#10;        correct_predictions,&#10;        test_inputs.len()&#10;    );&#10;&#10;    // Display confusion matrix&#10;    println!(&quot;\n--- Confusion Matrix ---&quot;);&#10;    println!(&quot;                  Predicted&quot;);&#10;    println!(&quot;                  Setosa  Versicolour&quot;);&#10;    println!(&#10;        &quot;Actual Setosa       {:&gt;3}      {:&gt;3}&quot;,&#10;        confusion_matrix[0][0], confusion_matrix[0][1]&#10;    );&#10;    println!(&#10;        &quot;       Versicolour  {:&gt;3}      {:&gt;3}&quot;,&#10;        confusion_matrix[1][0], confusion_matrix[1][1]&#10;    );&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>